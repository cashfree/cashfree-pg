/*
Cashfree Payment Gateway APIs

Cashfree's Payment Gateway APIs provide developers with a streamlined pathway to integrate advanced payment processing capabilities into their applications, platforms and websites.

API version: 2023-08-01
Contact: developers@cashfree.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cashfree_pg

import (
	"encoding/json"
	"strings"
)

// checks if the ReconEntityDataInner type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ReconEntityDataInner{}

// ReconEntityDataInner struct for ReconEntityDataInner
type ReconEntityDataInner struct {
	// Unique ID associated with the event.
	EventId *string `json:"event_id,omitempty"`
	// The event type can be SETTLEMENT, PAYMENT, REFUND, REFUND_REVERSAL, DISPUTE, DISPUTE_REVERSAL, CHARGEBACK, CHARGEBACK_REVERSAL, OTHER_ADJUSTMENT.
	EventType *string `json:"event_type,omitempty"`
	// Amount that is part of the settlement corresponding to the event.
	EventSettlementAmount *float32 `json:"event_settlement_amount,omitempty"`
	// Amount of the event. Example, refund amount, dispute amount, payment amount, etc.
	EventAmount *float32 `json:"event_amount,omitempty"`
	// Indicates if it is CREDIT/DEBIT sale.
	SaleType *string `json:"sale_type,omitempty"`
	// Status of the event. Example - SUCCESS, FAILED, PENDING, CANCELLED.
	EventStatus *string `json:"event_status,omitempty"`
	// Recon
	Entity *string `json:"entity,omitempty"`
	// Time associated with the event. Example, transaction time, dispute initiation time
	EventTime *string `json:"event_time,omitempty"`
	// Curreny type - INR.
	EventCurrency *string `json:"event_currency,omitempty"`
	// Unique order ID. Alphanumeric and only '-' and '_' allowed.
	OrderId *string `json:"order_id,omitempty"`
	// The amount which was passed at the order creation time.
	OrderAmount *float32 `json:"order_amount,omitempty"`
	// Customer phone number.
	CustomerPhone *string `json:"customer_phone,omitempty"`
	// Customer email.
	CustomerEmail *string `json:"customer_email,omitempty"`
	// Customer name.
	CustomerName *string `json:"customer_name,omitempty"`
	// Payment amount captured.
	PaymentAmount *float32 `json:"payment_amount,omitempty"`
	// Unique transaction reference number of the payment.
	PaymentUtr *string `json:"payment_utr,omitempty"`
	// Date and time when the payment was initiated.
	PaymentTime *string `json:"payment_time,omitempty"`
	// Service charge applicable for the payment.
	PaymentServiceCharge *float32 `json:"payment_service_charge,omitempty"`
	// Service tax applicable on the payment.
	PaymentServiceTax *float32 `json:"payment_service_tax,omitempty"`
	// Cashfree Payments unique ID to identify a payment.
	CfPaymentId *string `json:"cf_payment_id,omitempty"`
	// Unique ID to identify the settlement.
	CfSettlementId *string `json:"cf_settlement_id,omitempty"`
	// Date and time when the settlement was processed.
	SettlementDate *string `json:"settlement_date,omitempty"`
	// Unique transaction reference number of the settlement.
	SettlementUtr *string `json:"settlement_utr,omitempty"`
	// Service charge that is applicable for splitting the payment.
	SplitServiceCharge *float32 `json:"split_service_charge,omitempty"`
	// Service tax applicable for splitting the amount to vendors.
	SplitServiceTax *float32 `json:"split_service_tax,omitempty"`
	// Vendor commission applicable for this transaction.
	VendorCommission *float32 `json:"vendor_commission,omitempty"`
	// Specifies whether the dispute was closed in favor of the merchant or customer. /n Possible values - Merchant, Customer
	ClosedInFavorOf *string `json:"closed_in_favor_of,omitempty"`
	// Date and time when the dispute was resolved.
	DisputeResolvedOn *string `json:"dispute_resolved_on,omitempty"`
	// Category of the dispute - Dispute code and the reason for dispute is shown.
	DisputeCategory *string `json:"dispute_category,omitempty"`
	// Note regarding the dispute.
	DisputeNote *string `json:"dispute_note,omitempty"`
	// Date and time when the refund was processed.
	RefundProcessedAt *string `json:"refund_processed_at,omitempty"`
	// The bank reference number for the refund.
	RefundArn *string `json:"refund_arn,omitempty"`
	// A refund note for your reference.
	RefundNote *string `json:"refund_note,omitempty"`
	// An unique ID to associate the refund with.
	RefundId *string `json:"refund_id,omitempty"`
	// Other adjustment remarks.
	AdjustmentRemarks *string `json:"adjustment_remarks,omitempty"`
	// Amount that is adjusted from the settlement amount because of any credit/debit event such as refund, refund_reverse etc.
	Adjustment *float32 `json:"adjustment,omitempty"`
	// Service tax applicable on the settlement amount.
	ServiceTax *float32 `json:"service_tax,omitempty"`
	// Service charge applicable on the settlement amount.
	ServiceCharge *float32 `json:"service_charge,omitempty"`
	// Net amount that is settled after considering the adjustments, settlement charge and tax.
	AmountSettled *float32 `json:"amount_settled,omitempty"`
	// The start time of the time range of the payments considered for the settlement.
	PaymentFrom *string `json:"payment_from,omitempty"`
	// The end time of time range of the payments considered for the settlement.
	PaymentTill *string `json:"payment_till,omitempty"`
	// Reason for settlement failure.
	Reason *string `json:"reason,omitempty"`
	// Date and time when the settlement was initiated.
	SettlementInitiatedOn *string `json:"settlement_initiated_on,omitempty"`
	// Type of settlement. Possible values - Standard, Instant, On demand.
	SettlementType *string `json:"settlement_type,omitempty"`
	// Settlement charges applicable on the settlement.
	SettlementCharge *float32 `json:"settlement_charge,omitempty"`
	// Settlement tax applicable on the settlement.
	SettlementTax *float32 `json:"settlement_tax,omitempty"`
	// Remarks on the settlement.
	Remarks *string `json:"remarks,omitempty"`
}


func (o ReconEntityDataInner) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ReconEntityDataInner) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.EventId) {
		toSerialize["event_id"] = o.EventId
	}
	if !IsNil(o.EventType) {
		toSerialize["event_type"] = o.EventType
	}
	if !IsNil(o.EventSettlementAmount) {
		toSerialize["event_settlement_amount"] = o.EventSettlementAmount
	}
	if !IsNil(o.EventAmount) {
		toSerialize["event_amount"] = o.EventAmount
	}
	if !IsNil(o.SaleType) {
		toSerialize["sale_type"] = o.SaleType
	}
	if !IsNil(o.EventStatus) {
		toSerialize["event_status"] = o.EventStatus
	}
	if !IsNil(o.Entity) {
		toSerialize["entity"] = o.Entity
	}
	if !IsNil(o.EventTime) {
		toSerialize["event_time"] = o.EventTime
	}
	if !IsNil(o.EventCurrency) {
		toSerialize["event_currency"] = o.EventCurrency
	}
	if !IsNil(o.OrderId) {
		toSerialize["order_id"] = o.OrderId
	}
	if !IsNil(o.OrderAmount) {
		toSerialize["order_amount"] = o.OrderAmount
	}
	if !IsNil(o.CustomerPhone) {
		toSerialize["customer_phone"] = o.CustomerPhone
	}
	if !IsNil(o.CustomerEmail) {
		toSerialize["customer_email"] = o.CustomerEmail
	}
	if !IsNil(o.CustomerName) {
		toSerialize["customer_name"] = o.CustomerName
	}
	if !IsNil(o.PaymentAmount) {
		toSerialize["payment_amount"] = o.PaymentAmount
	}
	if !IsNil(o.PaymentUtr) {
		toSerialize["payment_utr"] = o.PaymentUtr
	}
	if !IsNil(o.PaymentTime) {
		toSerialize["payment_time"] = o.PaymentTime
	}
	if !IsNil(o.PaymentServiceCharge) {
		toSerialize["payment_service_charge"] = o.PaymentServiceCharge
	}
	if !IsNil(o.PaymentServiceTax) {
		toSerialize["payment_service_tax"] = o.PaymentServiceTax
	}
	if !IsNil(o.CfPaymentId) {
		toSerialize["cf_payment_id"] = o.CfPaymentId
	}
	if !IsNil(o.CfSettlementId) {
		toSerialize["cf_settlement_id"] = o.CfSettlementId
	}
	if !IsNil(o.SettlementDate) {
		toSerialize["settlement_date"] = o.SettlementDate
	}
	if !IsNil(o.SettlementUtr) {
		toSerialize["settlement_utr"] = o.SettlementUtr
	}
	if !IsNil(o.SplitServiceCharge) {
		toSerialize["split_service_charge"] = o.SplitServiceCharge
	}
	if !IsNil(o.SplitServiceTax) {
		toSerialize["split_service_tax"] = o.SplitServiceTax
	}
	if !IsNil(o.VendorCommission) {
		toSerialize["vendor_commission"] = o.VendorCommission
	}
	if !IsNil(o.ClosedInFavorOf) {
		toSerialize["closed_in_favor_of"] = o.ClosedInFavorOf
	}
	if !IsNil(o.DisputeResolvedOn) {
		toSerialize["dispute_resolved_on"] = o.DisputeResolvedOn
	}
	if !IsNil(o.DisputeCategory) {
		toSerialize["dispute_category"] = o.DisputeCategory
	}
	if !IsNil(o.DisputeNote) {
		toSerialize["dispute_note"] = o.DisputeNote
	}
	if !IsNil(o.RefundProcessedAt) {
		toSerialize["refund_processed_at"] = o.RefundProcessedAt
	}
	if !IsNil(o.RefundArn) {
		toSerialize["refund_arn"] = o.RefundArn
	}
	if !IsNil(o.RefundNote) {
		toSerialize["refund_note"] = o.RefundNote
	}
	if !IsNil(o.RefundId) {
		toSerialize["refund_id"] = o.RefundId
	}
	if !IsNil(o.AdjustmentRemarks) {
		toSerialize["adjustment_remarks"] = o.AdjustmentRemarks
	}
	if !IsNil(o.Adjustment) {
		toSerialize["adjustment"] = o.Adjustment
	}
	if !IsNil(o.ServiceTax) {
		toSerialize["service_tax"] = o.ServiceTax
	}
	if !IsNil(o.ServiceCharge) {
		toSerialize["service_charge"] = o.ServiceCharge
	}
	if !IsNil(o.AmountSettled) {
		toSerialize["amount_settled"] = o.AmountSettled
	}
	if !IsNil(o.PaymentFrom) {
		toSerialize["payment_from"] = o.PaymentFrom
	}
	if !IsNil(o.PaymentTill) {
		toSerialize["payment_till"] = o.PaymentTill
	}
	if !IsNil(o.Reason) {
		toSerialize["reason"] = o.Reason
	}
	if !IsNil(o.SettlementInitiatedOn) {
		toSerialize["settlement_initiated_on"] = o.SettlementInitiatedOn
	}
	if !IsNil(o.SettlementType) {
		toSerialize["settlement_type"] = o.SettlementType
	}
	if !IsNil(o.SettlementCharge) {
		toSerialize["settlement_charge"] = o.SettlementCharge
	}
	if !IsNil(o.SettlementTax) {
		toSerialize["settlement_tax"] = o.SettlementTax
	}
	if !IsNil(o.Remarks) {
		toSerialize["remarks"] = o.Remarks
	}
	return toSerialize, nil
}




func cashfreeStringTest() {
	strings.HasPrefix("cf", "cf")
}